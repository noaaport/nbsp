#
# $Id$
#

# This file contains the common portion of the rstfilter functions
# that are used also by the emwinfilter. This file requires
# the filters.lib functions.

# All the filter_xxxx functions return the list [status fpathout]
# In the rstfilter these return values are not used, but
# they are used by the emwinfilter.

proc filter_text {fpath savedir {savename ""}} {

    global rstfilter;

    cd $rstfilter(datadir);
    file mkdir $savedir;

    set fname [file tail $fpath];
    if {$savename eq ""} {
        append savename $fname $rstfilter(txt_fext);
    }
    set fpathout [file join $rstfilter(datadir) $savedir $savename];	

    set cmd [list nbspfile -t];      # do not add gempak-style headers
    if {$rstfilter(ccbsaved) == 0} {
	lappend cmd "-n";
    }

    # Instead of just
    #
    # lappend cmd -d $savedir -o $savename $fpath;
    #
    # filter through `tr` to remove (at least some of) the control characters
    # (\027 is contained in the weatherwire files; ending like "^WBRO-534385"
    # where ^W is the \027 (ETB) character). An alternative is to eliminate
    # all contrl characters except tab and \n. This list should be kept
    # in sync with the list in the variable filterslib(bodytxtre) in
    # filters.conf.
    #
    ## lappend cmd $fpath | tr -d {\001-\010\013-\037} > $fpathout;
    lappend cmd $fpath | tr -d {\r\001\003\036\027} > $fpathout;
    set status [catch {
	eval exec $cmd;
    } errmsg];

    set output [list $status $fpathout];

    if {$status != 0} {
	# In case it was created
	file delete $fpathout;
	log_msg $errmsg;
    } else {
	filter_text_insert_inventory $savedir $fpathout;
    }

    return $output;
}

proc filter_sat_goesr {fpath imgsavedir datasavedir imgsavename} {
    #
    # The "datasavename" is constructed from the imgsavename. The data (nc)
    # file is not kept by default; the variable "rstfilter(sat_goesr_keepnc)"
    # can be set to override this default.
    #
    # The default names are;
    #
    # knes_tire05+pao.112346_1414381 (raw spool file)
    # tire05pao_20250111_2346.gif
    # tire05pao_20250111_2346.nc
    #
    # The nc file is created for processing but it is removed afterwards,
    # unless the variable "rstfilter(sat_goesr_keepnc)" is set.
    #
    global rstfilter;

    #
    # Assume that imgsavename contains the img file extension (png by default)
    #
    set datafbasename [file rootname $imgsavename];
    append datafbasename $rstfilter(sat_goesr_datext);
    set datafpath [file join $rstfilter(datadir) $datasavedir $datafbasename];

    set _pwd [pwd];

    set status [catch {
	cd $rstfilter(datadir);
	file mkdir $datasavedir;
	#
	# Similar to the dafilter, remove the first line and leave the
	# pure nc file (see the dalib-sat.tcl). The first argument to
	# filterlib_exec_nbspfile is "seq", which would be used
	# by filterlib_exec_nbspfile when adding the gempak header.
	# In our case it will not be used, so we pass that argument as "0".
	#
	filterlib_exec_nbspfile 0 $fpath $datasavedir $datafbasename "-w";
    } errmsg];
    
    if {$status != 0} {
	# In case the file was created
	file delete $datafpath;
	set output [list 1 ""];
	log_msg $errmsg;
	
	return $output;
    }

    # Create the image
    cd $rstfilter(datadir);
    file mkdir $imgsavedir;

    set status [catch {
	exec nbspgoesr -d $imgsavedir -o $imgsavename $datafpath;	
    } errmsg];

    # The nc file is kept only if the flag is set and there are no errors.
    if {($status != 0) || ($rstfilter(sat_goesr_keepnc) == 0)} {
       file delete $datafpath;
    }
    
    if {$status != 0} {
	#
	# nbspgoesr deletes the image file in case of an error.
	#
	set output [list 1 ""];
	log_msg $errmsg;
	
	return $output;
    }

    set fpathout [file join $rstfilter(datadir) $imgsavedir $imgsavename];
    set output [list 0 $fpathout];

    # Insert both img and data files in sat inventory
    filter_sat_img_insert_inventory $imgsavedir $fpathout;
    if {$rstfilter(sat_goesr_keepnc) == 1} {
        filter_sat_insert_inventory $datasavedir $datafpath;
    }

    # Create the link to the latest
    make_sat_latest $imgsavedir [file tail $fpathout];
    if {$rstfilter(sat_goesr_keepnc) == 1} {
        make_sat_latest $datasavedir [file tail $datafpath];
    }

    cd $_pwd;

    return $output;
}

proc filter_rad {awips fpath savedir savename} {
#
# The awips is passed to nbspradmap (as a define) for the template use.
#
    global rstfilter;

    cd $rstfilter(datadir);
    file mkdir $savedir;
    set fpathout [file join $rstfilter(datadir) $savedir $savename];
    if {[file isdirectory $rstfilter(tmpdir)] == 1} {
        cd $rstfilter(tmpdir);
    }
    set status [nbspradmapproc $awips $fpath $fpathout];
    set output [list $status $fpathout];

    # nbspradmap (which is called by nbspradmapproc) does not create
    # the file in case of an error, so the is no need to do:
    #
    # if {$status != 0} {
    #	file delete $fpathout;
    # }

    if {$status == 0} {
	filter_rad_insert_inventory $savedir $fpathout;
	make_rad_latest $savedir [file tail $fpathout];
    }

    return $output;
}

proc nbspradmapproc {awips inputfile outputfile} {

    global rstfilter;

    # Create the inputfile without the ccb.
    set tmpfile ${outputfile}.tmp;

    set status [catch {exec nbsppipe -o $tmpfile $inputfile} errmsg];

    if {$status == 0} {
	set status [catch {exec nbspradmap -b \
	   -o $outputfile -s $rstfilter(rad_mapsize) -D awips=$awips \
	   $tmpfile $rstfilter(radmap_rcfile_fpath)} errmsg];
    }

    file delete $tmpfile;

#    In [-b] mode nbspradmap logs its own message
#    if {$status != 0} {
#	log_msg $errmsg;
#    }

    return $status;
}

#
# The rstnntp functions
#

proc rstnntp_open {} {

    global rstfilter;

    set status [catch {
	set rstfilter(RSTNNTP) [open "|$rstfilter(nntp)" w];
	fconfigure $rstfilter(RSTNNTP) -buffering line;
    } errmsg];

    if {$status == 0} {
	set rstfilter(RSTNNTP_open) 1;
    } else {
	log_msg $errmsg
    }
}

proc rstnntp_close {} {

    global rstfilter;

    if {$rstfilter(RSTNNTP_open) == 0} {
	return;
    }

    set status [catch {close $rstfilter(RSTNNTP)} errmsg];
    set rstfilter(RSTNNTP_open) 0;
    if {$status != 0} {
	log_msg $errmsg;
    }
}

proc rstnntp_is_open {} {

    global rstfilter;

    return $rstfilter(RSTNNTP_open);
}

proc rstnntp_send msg {

    global rstfilter;
    global errorInfo;

    if {$rstfilter(RSTNNTP_open) == 0} {
	log_msg "Connection to rstnntpfilter is closed.";
	return;
    }

    set status [catch {puts $rstfilter(RSTNNTP) $msg} errmsg];
    if {$status == 0} {
	return;
    }

    # If there as a write error, close the connection and retry.
    rstnntp_close;
    rstnntp_open;
    if {$rstfilter(RSTNNTP_open) == 0} {
	log_msg $errmsg;
	return;
    }

    set status [catch {puts $rstfilter(RSTNNTP) $msg} errmsg];
    if {$status != 0} {
	log_msg $errmsg;
	log_msg $errorInfo;
	return;
    }
}

#
# Same thing for rss
#

proc rss_open {} {

    global rstfilter;

    set status [catch {
	set rstfilter(RSS) [open "|$rstfilter(rss)" w];
	fconfigure $rstfilter(RSS) -buffering line;
    } errmsg];

    if {$status == 0} {
	set rstfilter(RSS_open) 1;
    } else {
	log_msg $errmsg
    }
}

proc rss_close {} {

    global rstfilter;

    if {$rstfilter(RSS_open) == 0} {
	return;
    }

    set status [catch {close $rstfilter(RSS)} errmsg];
    set rstfilter(RSS_open) 0;
    if {$status != 0} {
	log_msg $errmsg;
    }
}

proc rss_is_open {} {

    global rstfilter;

    return $rstfilter(RSS_open);
}

proc rss_send msg {

    global rstfilter;
    global errorInfo;

    if {$rstfilter(RSS_open) == 0} {
	log_msg "Connection to rssfilter is closed.";
	return;
    }

    set status [catch {puts $rstfilter(RSS) $msg} errmsg];
    if {$status == 0} {
	return;
    }

    # If there as a write error, close the connection and retry.
    rss_close;
    rss_open;
    if {$rstfilter(RSS_open) == 0} {
	log_msg $errmsg;
	return;
    }

    set status [catch {puts $rstfilter(RSS) $msg} errmsg];
    if {$status != 0} {
	log_msg $errmsg;
	log_msg $errorInfo;
	return;
    }
}

#
# Functions to make the link to the latest
#

proc make_latest {savedir savename latestname} {
#
# Create a link to the newest file.
#
    global rstfilter;

    set currentdir [pwd];

    set dirpath [file join $rstfilter(datadir) $savedir];
    cd $dirpath;

    set latest $savename;
    set linkpath $latestname;
    if {[file exists $latest] == 0} {
 	cd $currentdir;
	return;
    }

    set status [catch {
        file delete $linkpath;
        # file link -symbolic $linkpath $latest;
	exec ln -s $latest $linkpath;
    } errmsg];

    cd $currentdir;
}

proc make_sat_latest {savedir savename} {

    global rstfilter;

    if {$rstfilter(sat_latest_enable) == 0} {
	return;
    }

    make_latest $savedir $savename $rstfilter(sat_latestname);
}

proc make_rad_latest {savedir savename} {

    global rstfilter;

    if {$rstfilter(rad_latest_enable) == 0} {
	return;
    }

    make_latest $savedir $savename $rstfilter(rad_latestname);
}

#
# Functions to support the inventory for the cleanup process
#
proc filter_insert_inventory {invsubdir savedir fpathout} {
#
# The "savedir" is the subdirectory where the data file was saved. It is
# used here to construct a unique name for the inventory file so that all
# the data files in a given subdirectory appear in the same inventory file.
#
    global rstfilter;

    # The rst invdir must exist
    if {[file isdirectory $rstfilter(invdir)] == 0} {
	log_msg "No $rstfilter(invdir)";
	return;
    }

    # The inventory files are saved in hourly subdirectories within
    # rst/<invsubdir>; e.g.,
    # rst/txt/<yyyymmddhh>/<inv_file>
    #
    set parentdir [file join $rstfilter(invdir) $invsubdir \
      [clock format [clock seconds] -format $rstfilter(invformat) -gmt true]];
    file mkdir $parentdir;

    set invfile_name [join [file split $savedir] "."];
    set invfile [file join $parentdir $invfile_name];

    filterlib_file_append $invfile $fpathout;
}

proc filter_text_insert_inventory {savedir fpathout} {

    global rstfilter;

    if {$rstfilter(txt_inv_enable) == 0} {
	return;
    }
    filter_insert_inventory $rstfilter(txtinvsubdir) $savedir $fpathout;
}

proc filter_rad_insert_inventory {savedir fpathout} {

    global rstfilter;

    if {$rstfilter(rad_inv_enable) == 0} {
	return;
    }
    filter_insert_inventory $rstfilter(radinvsubdir) $savedir $fpathout;
}

proc filter_sat_insert_inventory {savedir fpathout} {

    global rstfilter;

    if {$rstfilter(sat_inv_enable) == 0} {
	return;
    }
    filter_insert_inventory $rstfilter(satinvsubdir) $savedir $fpathout;
}

proc filter_sat_img_insert_inventory {savedir fpathout} {

    global rstfilter;

    if {$rstfilter(sat_inv_enable) == 0} {
	return;
    }

    # At the time this function is called, either filter_satplain or
    # filter_satmap will have run, and anyone could have created
    # a png and/or gif file, depending on configuration options. Instead
    # of keeping track of all the possible combinations in all possible
    # places, here we could try to detect the presence of both images
    # and insert them in the inventory if they are found. In addition,
    # the emwinfilter will create a jpg file if it is running,
    # and it cannot be the emwinfilter's responsibility to insert it because
    # it would not know what inventory file to use. For this reason
    # our strategy will be to insert all types unconditionally here.
 
    set fpathout_rootname [file rootname $fpathout];

    # $rstfilter(sat_inv_image_types) is a list, of which each element is a
    # a two-item list if the form {image_type flag}. If the flag is 0, then
    # before inserting the particular file type in the inventory the function
    # checks if the file exists. If the flag is different from 0 then the
    # file is inserted unconditionally. png and gif can be used with flag = 0,
    # but jpg must be inserted unconditionally if the emwin filter is enabled
    # because the file does not exist by the time this function is called.

    foreach typelist $rstfilter(sat_inv_image_types) {
	set fpath "";
	set type [lindex $typelist 0];
	set flag [lindex $typelist 1];
	append fpath $fpathout_rootname "." $type;
	if {$flag != 0} { 
	    filter_insert_inventory $rstfilter(satinvsubdir) $savedir $fpath;
	} elseif {[file exists $fpath]} {
	    filter_insert_inventory $rstfilter(satinvsubdir) $savedir $fpath;
	}
    }
}
